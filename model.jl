
@everywhere function MVPF(c,data)

    #We Start by solving the MVP
    MVP = Model(solver=GurobiSolver(OutputFlag=0));
    
    if c==1
        @variable(MVP,xx[1:nbHydroP,c:nbStages]>=0); #water level of hydro plant h in stage 1
        @variable(MVP,yy[1:nbHydroP,c:nbStages]>=0); #amount of turbined water flow released by plant h in stage 1
        @variable(MVP,ss[1:nbHydroP,c:nbStages]>=0); #amount of spilled water (without generating power) by plant h in stage 1
        @variable(MVP,gg[1:nbThermoP,c:nbStages]>=0); #amount of thermal power generated by plant f in stage 1
        @variable(MVP,pp[c:nbStages]>=0); #amount of unsatisfied demand in stage 1
    else
        @variable(MVP,xx[1:nbHydroP,c-1:nbStages]>=0); #water level of hydro plant h in stage t
        @variable(MVP,yy[1:nbHydroP,c:nbStages]>=0); #amount of turbined water flow released by plant h in stage t
        @variable(MVP,ss[1:nbHydroP,c:nbStages]>=0); #amount of spilled water (without generating power) by plant h in stage t
        @variable(MVP,gg[1:nbThermoP,c:nbStages]>=0); #amount of thermal power generated by plant f in stage t
        @variable(MVP,pp[c:nbStages]>=0); #amount of unsatisfied demand in stage t
    end
    
    @objective(MVP,Min,sum(sum(cf[f]*gg[f,t] for f=1:nbThermoP)+cp*pp[t] for t=c:nbStages));
    
    if c==1
        for h in HReserv
            if length(Graph[h])>=1
                @constraint(MVP, xx[h,c]==x0[h]+c0*(scen[c,2+h]+(sum(yy[m,c]+ss[m,c] for m in Graph[h]))-(yy[h,c]+ss[h,c])));
            else
                @constraint(MVP, xx[h,c]==x0[h]+c0*(scen[c,2+h]-(yy[h,c]+ss[h,c])));
            end
        end
        
        for h in HNoReserv
            if length(Graph[h])>=1
                @constraint(MVP, yy[h,c]+ss[h,c]==scen[c,2+h]+(sum(yy[m,c]+ss[m,c] for m in Graph[h])));
            else
                @constraint(MVP, yy[h,c]+ss[h,c]==scen[c,2+h]);
            end
        end
        
        for t=2:nbStages
            for h in HReserv
                if length(Graph[h]) >=1
                    @constraint(MVP, xx[h,t]==xx[h,t-1]+c0*((sum(scen[1+nbRealization*(t-2)+k,2+h] for k=1:nbRealization)/nbRealization)+(sum(yy[m,t]+ss[m,t] for m in Graph[h]))-(yy[h,t]+ss[h,t])));
                else
                    @constraint(MVP, xx[h,t]==xx[h,t-1]+c0*((sum(scen[1+nbRealization*(t-2)+k,2+h] for k=1:nbRealization)/nbRealization)-(yy[h,t]+ss[h,t])));
                end
            end
            
            for h in HNoReserv
                if length(Graph[h])>=1
                    @constraint(MVP, yy[h,t]+ss[h,t]==(scen[t,2+h]+(sum(yy[m,t]+ss[m,t] for m in Graph[h]))));
                else
                    @constraint(MVP, yy[h,t]+ss[h,t]==scen[t,2+h]);
                end
            end            
        end
        
    else
        for t=c:nbStages
            for h in HReserv
                if length(Graph[h])>=1
                    @constraint(MVP, xx[h,t]==xx[h,t-1]+c0*((sum(scen[1+nbRealization*(t-2)+k,2+h] for k=1:nbRealization)/nbRealization)+(sum(yy[m,t]+ss[m,t] for m in Graph[h]))-(yy[h,t]+ss[h,t])));
                else
                    @constraint(MVP, xx[h,t]==xx[h,t-1]+c0*((sum(scen[1+nbRealization*(t-2)+k,2+h] for k=1:nbRealization)/nbRealization)-(yy[h,t]+ss[h,t])));                
                end
            end
            for h in HNoReserv
                if length(Graph[h])>=1
                    @constraint(MVP, yy[h,t]+ss[h,t]==(sum(scen[1+nbRealization*(t-2)+k,2+h] for k=1:nbRealization)/nbRealization)+(sum(yy[m,t]+ss[m,t] for m in Graph[h])));
                else
                    @constraint(MVP, yy[h,t]+ss[h,t]==(sum(scen[1+nbRealization*(t-2)+k,2+h] for k=1:nbRealization)/nbRealization));
                end
            end  
        end
        
        for h in HReserv
        #for h=1:nbHydroP
            @constraint(MVP, xx[h,c-1]<=vup[h]);
            @constraint(MVP, xx[h,c-1]>=vlow[h]);
        end
        
        
    end
    
    
    for t=c:nbStages 
        @constraint(MVP, sum(rh[h]*yy[h,t] for h=1:nbHydroP)+sum(gg[f,t] for f=1:nbThermoP)+pp[t]>=demand[t]);
        
        
        for h=1:nbHydroP
            @constraint(MVP, yy[h,t]<=qbar[h]);
        end
        
        for f=1:nbThermoP
            @constraint(MVP, gg[f,t]<=fbar[f])
        end


        for h in HReserv
        #for h=1:nbHydroP
            @constraint(MVP, xx[h,t]<=vup[h]);
            @constraint(MVP, xx[h,t]>=vlow[h]);
        end
        
    end 

    #@constraint(MVP, xx[nbStages]==x0);
    
    status = solve(MVP);
    obj = getobjectivevalue(MVP);
    xxvalue = getvalue(xx)
    
    return obj, xxvalue
end

MVPobj = zeros(nbStages);
xvaluelist = [];
for t=1:nbStages
    obj, xxvalue = MVPF(t,data);
    MVPobj[t]=obj;
    push!(xvaluelist,xxvalue)
end

MasterSub = [];
xvar = [];
yvar = [];
svar = [];
gvar = [];
pvar = [];
thetavar = [];
FBconstr = [];

for t=1:nbStages
    LP = Model(solver=GurobiSolver(OutputFlag=0));
    
    if t<nbStages
        @variable(LP,theta[t:t]>=0); #Expected Cost to go function at time t
    end
    
    @variable(LP,x[1:nbHydroP,t:t]>=0); #water level of hydro plant h in stage t
    @variable(LP,y[1:nbHydroP,t:t]>=0); #amount of turbined water flow released by plant h in stage t
    @variable(LP,s[1:nbHydroP,t:t]>=0); #amount of spilled water (without generating power) by plant h in stage t
    @variable(LP,g[1:nbThermoP,t:t]>=0); #amount of thermal power generated by plant f in stage t
    @variable(LP,p[t:t]>=0); #amount of unsatisfied demand in stage t
    
    if t<nbStages
        @objective(LP,Min,sum(cf[f]*g[f,t] for f=1:nbThermoP)+cp*p[t]+theta[t]);
        #Constraint to make sure that the Master problem is bounded using the MVP
        @constraint(LP, sum(cf[f]*g[f,t] for f=1:nbThermoP)+cp*p[t]+theta[t]>=MVPobj[t]);
    else
        @objective(LP,Min,sum(cf[f]*g[f,t] for f=1:nbThermoP)+cp*p[t]);
        @constraint(LP, sum(cf[f]*g[f,t] for f=1:nbThermoP)+cp*p[t]>=MVPobj[t]);
        #@constraint(LP, x[t]==x0);
    end
        
    templist = [];
    for h=1:nbHydroP
        push!(templist,zero(AffExpr))
    end
    if t==1
        for h in HReserv
            if length(Graph[h])>=1
                templist[h]= @constraint(LP, x[h,t]==x0[h]+c0*(scen[t,2+h]+(sum(y[m,t]+s[m,t] for m in Graph[h]))-(y[h,t]+s[h,t])));
            else
                templist[h]= @constraint(LP, x[h,t]==x0[h]+c0*(scen[t,2+h]-(y[h,t]+s[h,t])));
            end
        end
        for h in HNoReserv
            if length(Graph[h])>=1
                templist[h]= @constraint(LP, y[h,t]+s[h,t]==scen[t,2+h]+(sum(y[m,t]+s[m,t] for m in Graph[h])));
            else
                templist[h]= @constraint(LP, y[h,t]+s[h,t]==scen[t,2+h]);
            end
        end        
    else
        for h in HReserv
            if length(Graph[h])>=1
                templist[h] = @constraint(LP, x[h,t]-c0*((sum(y[m,t]+s[m,t] for m in Graph[h]))-(y[h,t]+s[h,t]))==0);
            else
                templist[h] = @constraint(LP, x[h,t]+c0*((y[h,t]+s[h,t]))==0);
            end
        end
        for h in HNoReserv
            if length(Graph[h])>=1
                templist[h] = @constraint(LP, y[h,t]+s[h,t]-(sum(y[m,t]+s[m,t] for m in Graph[h]))==0);
            else
                templist[h] = @constraint(LP, y[h,t]+s[h,t]==0);
            end
        end  
    end
    
    @constraint(LP, sum(rh[h]*y[h,t] for h=1:nbHydroP)+sum(g[f,t] for f=1:nbThermoP)+p[t]>=demand[t]);
        
    for h=1:nbHydroP
        @constraint(LP, y[h,t]<=qbar[h]);
    end  
    for f=1:nbThermoP
        @constraint(LP, g[f,t]<=fbar[f])
    end
    for h in HReserv
    #for h=1:nbHydroP
        @constraint(LP, x[h,t]<=vup[h]);
        @constraint(LP, x[h,t]>=vlow[h]);
    end

    
    push!(MasterSub,LP)
    push!(xvar,x)
    push!(yvar,y)
    push!(svar,s)
    push!(gvar,g)
    push!(pvar,p[t])
    if t<nbStages
        push!(thetavar,theta[t])
    end
    push!(FBconstr,templist)
end
MasterSubData = MasterSub, xvar, yvar, svar, gvar, pvar, thetavar, FBconstr, MVPobj;
